{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Gerson/Desktop/programming/react/dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _createForOfIteratorHelper from \"C:/Users/Gerson/Desktop/programming/react/dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _asyncToGenerator from \"C:/Users/Gerson/Desktop/programming/react/dashboard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport invariant from 'invariant';\nexport var BluetoothEvent;\n\n(function (BluetoothEvent) {\n  BluetoothEvent[\"onAvailabilityChanged\"] = \"onavailabilitychanged\";\n  BluetoothEvent[\"onGATTServerDisconnected\"] = \"ongattserverdisconnected\";\n  BluetoothEvent[\"onCharacteristicValueChanged\"] = \"oncharacteristicvaluechanged\";\n  BluetoothEvent[\"onServiceAdded\"] = \"onserviceadded\";\n  BluetoothEvent[\"onServiceChanged\"] = \"onservicechanged\";\n  BluetoothEvent[\"onServiceRemoved\"] = \"onserviceremoved\";\n})(BluetoothEvent || (BluetoothEvent = {}));\n\nvar platformListeners = {};\nexport var isCapable = ('bluetooth' in navigator);\n/* TODO: Bacon: Web: This will show a modal and allow you to select one. We may need to build a custom component to do this on native. */\n\nexport function requestDeviceAsync() {\n  return _requestDeviceAsync.apply(this, arguments);\n}\n\nfunction _requestDeviceAsync() {\n  _requestDeviceAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var options,\n        device,\n        _args = arguments;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {\n              acceptAllDevices: true\n            };\n            _context.prev = 1;\n            _context.next = 4;\n            return platformModule().requestDevice(options);\n\n          case 4:\n            device = _context.sent;\n            return _context.abrupt(\"return\", {\n              type: 'success',\n              device: device\n            });\n\n          case 8:\n            _context.prev = 8;\n            _context.t0 = _context[\"catch\"](1);\n\n            if (!(_context.t0.code === 8)) {\n              _context.next = 12;\n              break;\n            }\n\n            return _context.abrupt(\"return\", {\n              type: 'cancel'\n            });\n\n          case 12:\n            throw _context.t0;\n\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[1, 8]]);\n  }));\n  return _requestDeviceAsync.apply(this, arguments);\n}\n\nexport function getAvailabilityAsync() {\n  return _getAvailabilityAsync.apply(this, arguments);\n}\n\nfunction _getAvailabilityAsync() {\n  _getAvailabilityAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    var bluetooth;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            bluetooth = platformModule();\n\n            if (!bluetooth.getAvailability) {\n              _context2.next = 7;\n              break;\n            }\n\n            _context2.next = 4;\n            return platformModule().getAvailability();\n\n          case 4:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 7:\n            return _context2.abrupt(\"return\", !!bluetooth);\n\n          case 8:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _getAvailabilityAsync.apply(this, arguments);\n}\n\nexport function getReferringDevice() {\n  return platformModule().referringDevice;\n}\nexport function addPlatformHandler(eventName, handler) {\n  if (!(eventName in platformListeners)) {\n    platformListeners[eventName] = [];\n  }\n\n  platformListeners[eventName].push(handler);\n  return {\n    remove: function remove() {\n      var index = platformListeners[eventName].indexOf(handler);\n\n      if (index !== -1) {\n        platformListeners[eventName].splice(index, 1);\n      }\n    }\n  };\n}\n/* In theory these event listeners shouldn't matter */\n// type: 'availabilitychanged'\n\nexport function addEventListener(listener, useCapture) {\n  platformModule().addEventListener('availabilitychanged', listener, useCapture);\n}\nexport function dispatchEvent(event) {\n  return platformModule().dispatchEvent(event);\n}\nexport function removeEventListener(callback, options) {\n  platformModule().removeEventListener('availabilitychanged', callback, options);\n}\n\nfunction platformModule() {\n  var _navigator = navigator;\n  invariant(_navigator.bluetooth, 'This device is not capable of using Bluetooth');\n  return _navigator.bluetooth;\n}\n\nfunction _setupHandlers() {\n  var events = [BluetoothEvent.onAvailabilityChanged, BluetoothEvent.onGATTServerDisconnected, BluetoothEvent.onCharacteristicValueChanged, BluetoothEvent.onServiceAdded, BluetoothEvent.onServiceChanged, BluetoothEvent.onServiceRemoved];\n\n  var _loop = function _loop() {\n    var eventName = _events[_i];\n\n    /* This could be messy if the developer redefines these values */\n    platformModule()[eventName] = function () {\n      var subscriptions = platformListeners[eventName];\n\n      var _iterator = _createForOfIteratorHelper(subscriptions),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var subscription = _step.value;\n          subscription.apply(void 0, arguments);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    };\n  };\n\n  for (var _i = 0, _events = events; _i < _events.length; _i++) {\n    _loop();\n  }\n}\n\n_setupHandlers();","map":{"version":3,"sources":["C:/Users/Gerson/Desktop/programming/react/dashboard/node_modules/react-bluetooth/build/Bluetooth.js"],"names":["invariant","BluetoothEvent","platformListeners","isCapable","navigator","requestDeviceAsync","options","acceptAllDevices","platformModule","requestDevice","device","type","code","getAvailabilityAsync","bluetooth","getAvailability","getReferringDevice","referringDevice","addPlatformHandler","eventName","handler","push","remove","index","indexOf","splice","addEventListener","listener","useCapture","dispatchEvent","event","removeEventListener","callback","_navigator","_setupHandlers","events","onAvailabilityChanged","onGATTServerDisconnected","onCharacteristicValueChanged","onServiceAdded","onServiceChanged","onServiceRemoved","subscriptions","subscription"],"mappings":"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","sourcesContent":["import invariant from 'invariant';\nexport var BluetoothEvent;\n(function (BluetoothEvent) {\n    BluetoothEvent[\"onAvailabilityChanged\"] = \"onavailabilitychanged\";\n    BluetoothEvent[\"onGATTServerDisconnected\"] = \"ongattserverdisconnected\";\n    BluetoothEvent[\"onCharacteristicValueChanged\"] = \"oncharacteristicvaluechanged\";\n    BluetoothEvent[\"onServiceAdded\"] = \"onserviceadded\";\n    BluetoothEvent[\"onServiceChanged\"] = \"onservicechanged\";\n    BluetoothEvent[\"onServiceRemoved\"] = \"onserviceremoved\";\n})(BluetoothEvent || (BluetoothEvent = {}));\nlet platformListeners = {};\nexport const isCapable = 'bluetooth' in navigator;\n/* TODO: Bacon: Web: This will show a modal and allow you to select one. We may need to build a custom component to do this on native. */\nexport async function requestDeviceAsync(options = { acceptAllDevices: true }) {\n    try {\n        const device = await platformModule().requestDevice(options);\n        return { type: 'success', device };\n    }\n    catch (error) {\n        if (error.code === 8) {\n            // User Cancelled\n            return { type: 'cancel' };\n        }\n        throw error;\n    }\n}\nexport async function getAvailabilityAsync() {\n    const bluetooth = platformModule();\n    if (bluetooth.getAvailability) {\n        return await platformModule().getAvailability();\n    }\n    else {\n        return !!bluetooth;\n    }\n}\nexport function getReferringDevice() {\n    return platformModule().referringDevice;\n}\nexport function addPlatformHandler(eventName, handler) {\n    if (!(eventName in platformListeners)) {\n        platformListeners[eventName] = [];\n    }\n    platformListeners[eventName].push(handler);\n    return {\n        remove() {\n            const index = platformListeners[eventName].indexOf(handler);\n            if (index !== -1) {\n                platformListeners[eventName].splice(index, 1);\n            }\n        },\n    };\n}\n/* In theory these event listeners shouldn't matter */\n// type: 'availabilitychanged'\nexport function addEventListener(listener, useCapture) {\n    platformModule().addEventListener('availabilitychanged', listener, useCapture);\n}\nexport function dispatchEvent(event) {\n    return platformModule().dispatchEvent(event);\n}\nexport function removeEventListener(callback, options) {\n    platformModule().removeEventListener('availabilitychanged', callback, options);\n}\nfunction platformModule() {\n    const _navigator = navigator;\n    invariant(_navigator.bluetooth, 'This device is not capable of using Bluetooth');\n    return _navigator.bluetooth;\n}\nfunction _setupHandlers() {\n    const events = [\n        BluetoothEvent.onAvailabilityChanged,\n        BluetoothEvent.onGATTServerDisconnected,\n        BluetoothEvent.onCharacteristicValueChanged,\n        BluetoothEvent.onServiceAdded,\n        BluetoothEvent.onServiceChanged,\n        BluetoothEvent.onServiceRemoved,\n    ];\n    for (const eventName of events) {\n        /* This could be messy if the developer redefines these values */\n        platformModule()[eventName] = (...event) => {\n            const subscriptions = platformListeners[eventName];\n            for (const subscription of subscriptions) {\n                subscription(...event);\n            }\n        };\n    }\n}\n_setupHandlers();\n//# sourceMappingURL=Bluetooth.js.map"]},"metadata":{},"sourceType":"module"}